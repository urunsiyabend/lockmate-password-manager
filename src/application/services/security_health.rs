use std::collections::HashMap;

use chrono::Utc;
use serde_json::json;
use surrealdb::Error as DbError;
use thiserror::Error;

use crate::application::services::vault::{self, VaultDataError};
use crate::domain::models::security_health::{
    NewSecurityHealthFindingRecord, SecurityHealthFindingKind, SecurityHealthFindingRecord,
    SecurityHealthSeverity, SecurityHealthSummary,
};
use crate::infrastructure::data::repositories::{
    security_health_repository::SecurityHealthFindingRepository,
    vault_item_repository::VaultItemRepository,
};
use crate::infrastructure::security::{
    crypto::VaultItemCiphertext,
    k_anonymity::{KAnonymityClient, KAnonymityError},
};

#[derive(Debug, Error)]
pub enum SecurityHealthError {
    #[error("failed to load vault data: {0}")]
    Database(#[from] DbError),
    #[error("vault data error: {0}")]
    Vault(#[from] VaultDataError),
    #[error("breach lookup failed: {0}")]
    Breach(#[from] KAnonymityError),
}

#[derive(Clone, Debug)]
struct DecryptedVaultItem {
    id: String,
    title: String,
    username: Option<String>,
    url: Option<String>,
    password: Option<String>,
}

impl DecryptedVaultItem {
    fn affected_metadata(&self) -> serde_json::Value {
        json!({
            "id": self.id,
            "title": self.title,
            "username": self.username,
            "url": self.url,
        })
    }
}

pub async fn refresh_security_health(
    user_id: &str,
    vault_key: &str,
) -> Result<SecurityHealthSummary, SecurityHealthError> {
    let findings = run_health_check(user_id, vault_key).await?;
    Ok(findings.into())
}

pub async fn get_security_health_summary(
    user_id: &str,
) -> Result<SecurityHealthSummary, SecurityHealthError> {
    let repository = SecurityHealthFindingRepository::new();
    let findings = repository.list_by_user(user_id).await?;
    Ok(findings.into())
}

async fn run_health_check(
    user_id: &str,
    vault_key: &str,
) -> Result<Vec<SecurityHealthFindingRecord>, SecurityHealthError> {
    let vault_repository = VaultItemRepository::new();
    let health_repository = SecurityHealthFindingRepository::new();
    let breach_client = KAnonymityClient::new();

    let records = vault_repository.list_by_user(user_id).await?;
    let mut decrypted = Vec::with_capacity(records.len());

    for record in records {
        let ciphertext = VaultItemCiphertext {
            ciphertext: record.ciphertext.clone(),
            nonce: record.nonce.clone(),
        };
        let payload = vault::decrypt_payload(vault_key, &ciphertext)?;

        decrypted.push(DecryptedVaultItem {
            id: record.id,
            title: payload.title,
            username: payload.username,
            url: payload.url,
            password: payload.password,
        });
    }

    let mut password_index: HashMap<String, Vec<usize>> = HashMap::new();
    for (index, item) in decrypted.iter().enumerate() {
        if let Some(password) = item.password.as_ref() {
            let normalized = password.trim();
            if normalized.is_empty() {
                continue;
            }
            password_index
                .entry(normalized.to_string())
                .or_default()
                .push(index);
        }
    }

    let mut new_findings: Vec<NewSecurityHealthFindingRecord> = Vec::new();
    let now = Utc::now();

    for indices in password_index.values().filter(|indices| indices.len() > 1) {
        let affected: Vec<&DecryptedVaultItem> =
            indices.iter().map(|idx| &decrypted[*idx]).collect();

        let title = format!("Password reused across {} entries", affected.len());
        let description = "Using the same password for multiple credentials increases risk. A unique password per entry is recommended.".to_string();
        let remediation = "Update each affected item with a unique, strong password generated by the password manager.".to_string();
        let vault_item_ids = affected.iter().map(|item| item.id.clone()).collect();
        let metadata = json!({
            "affected_items": affected.iter().map(|item| item.affected_metadata()).collect::<Vec<_>>(),
            "item_count": affected.len(),
            "issue": "reused_password",
        });

        new_findings.push(NewSecurityHealthFindingRecord {
            user_id: user_id.to_string(),
            kind: SecurityHealthFindingKind::ReusedCredential,
            severity: SecurityHealthSeverity::Medium,
            title,
            description,
            remediation,
            vault_item_ids,
            metadata: Some(metadata),
            created_at: now,
        });
    }

    for (password, indices) in &password_index {
        let breach_count = breach_client.breached_count(password).await?;
        if breach_count == 0 {
            continue;
        }

        let affected: Vec<&DecryptedVaultItem> =
            indices.iter().map(|idx| &decrypted[*idx]).collect();

        let title = "Password exposed in known data breaches".to_string();
        let description = format!(
            "A password used by {} of your items appears in {breach_count} known breach records.",
            affected.len()
        );
        let remediation = "Change the password immediately and enable multi-factor authentication wherever possible.".to_string();
        let vault_item_ids = affected.iter().map(|item| item.id.clone()).collect();
        let metadata = json!({
            "affected_items": affected.iter().map(|item| item.affected_metadata()).collect::<Vec<_>>(),
            "breach_count": breach_count,
            "issue": "breached_password",
        });

        new_findings.push(NewSecurityHealthFindingRecord {
            user_id: user_id.to_string(),
            kind: SecurityHealthFindingKind::BreachedCredential,
            severity: SecurityHealthSeverity::High,
            title,
            description,
            remediation,
            vault_item_ids,
            metadata: Some(metadata),
            created_at: now,
        });
    }

    let stored = health_repository
        .replace_for_user(user_id, &new_findings)
        .await?;

    Ok(stored)
}
